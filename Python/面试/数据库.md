
- 关系型（MySQL）
- 非关系型（Mongodb,Redis）


## 4.1 MySQL

>(1) 数据库事务

事务是一个原子操作。是一个最小执行单元。可以甶一个或多个SQL语句组成。

具有以下4大特性：
- 原子性：整个事务的所有操作要么全部完成，要么全部不完成
- 持久性：在事务完成后，该事务所有的操作都将持久化在数据库中，不会被回滚
- 一致性：在事务开始之前和事务结束之后，数据库的完整性约束并没有破坏
- 隔离性：确保在同一时间内只有一个事务处理某个数据

ACID，即 atomicity, consistency, isolation, durability

参考：[【mysql】ACID靠什么保证的？](https://blog.csdn.net/m0_45406092/article/details/120314845)

>(2) 事务都有哪些操作？

主要操作：
- 开启事务（start transaction）
- 提交事务（commit）
- 回滚事务（rollback）


demo:

```sql
BEGIN TRANSACTION;

INSERT INTO customers (name, email) VALUES ('John Doe', 'johndoe@example.com');
INSERT INTO orders (customer_id, product, quantity) VALUES (1, 'Product A', 2);

COMMIT;
```



>(3) 数据库索引

索引会对数据库表中一列或多列的值进行排序的一种结构，使用索引可以加快检索表中数据。

优点：大大加快数据的检索速度；通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

缺点：创建索引和维护索引需要耗费时间和空间


其它：
- [聊聊索引失效的10种场景](https://zhuanlan.zhihu.com/p/455188214) ⭐️
- [深入理解MySQL索引设计和优化原则](https://cloud.tencent.com/developer/article/1691456)

>(4) 数据库索引使用了什么数据结构？

为了加快查找速度，一般使用数据结构：哈希、树，

虽然哈希增删改查都是O(1)，树增删改查都是O（logn），但对于排序查询的SQL需求，哈希会退化为O(n)，树型仍是O(logn)

数据库索引使用的是 **B+树**

参考：
- [MySQL索引背后的数据结构及算法原理](https://blog.codinglabs.org/articles/theory-of-mysql-index.html)
- [深入理解MySQL索引底层数据结构](https://www.cnblogs.com/itwxe/p/15783164.html)


>(5) B+树和B树的区别

B树，又称多路平衡查找树；

B+树，是应对数据库所需要而出现的一种 B树的变形树。

主要差异：
- B树中，n个关键字的结点含有n+1棵子树；B+树中，n个关键字的结点含有n棵子树
- B+树中，叶结点包含了全部关键字，所有非叶结点仅起索引作用。但在B树中，关键字除了分布在叶结点中，还会分布在其它结点中，这样不利于扫库。


>(6) 为什么MySQL的索引结构使用的是 B+树 而不是 B树？ 

- B+树的磁盘读写代价更低，B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小。
- B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。
- 由于B+树的数据都存储在叶子结点中，**分支结点均为索引，方便扫库**，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

>(7) 聚集索引与非聚集索引

聚集索引，物理顺序与其逻辑顺序相同，一个表中只能拥有一个聚集索引。

非聚集索引，该索引中索引的逻辑顺序与磁盘上的物理存储顺序不同，一个表中可以拥有多个非聚集索引。

二者比起来，聚集索引中行数据在物理存储器中的真实地址就是按照主键索引树形成的顺序进行排列的，所以查询效率快，但是修改慢。

>(8) 数据库的三大范式

1NF ：关系中每个属性都是不可再分的原子项（列不可再分）

2NF ：满足第一范式，且不存在非主属性对主码部分函数依赖（属性完全依赖于主键）

3NF ：满足第一范式，且每个非主属性都不传递函数依赖于主码.（属性不依赖于其它非主属性，属性直接依赖于主键）

>(9) 隔离级别

隔离性（多个并发事务之间对共享数据的处理应当相互隔离）

数据库事务的隔离级别有4种，由低到高分别为

- Read uncommitted（读未提交）（一个事务可以读取另一个未提交事务的数据。）
- Read committed（读提交）（只能读到已经提交了的内容）
  - 解决了**脏读**（一个事务读取的数据是另一个事务修改未提交的错误数据）。
- Repeatable read（可重复读）（事务开启后，不允许其它事务的修改操作）（MySQL默认隔离级别）
  - 解决了**不可重复读**（一个事务内两次连续读到的数据是不一样的，中途被其它UPDATE了）
- Serializable（序列化）
  - 解决了**幻读**（一个事务内两次连续读到的数据是不一样的，中途被其它INSERT了）
  - 数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。

参考：[数据库的4种隔离级别](https://www.cnblogs.com/myseries/p/10748912.html)

>(10) 说说数据库存储引擎

数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MYSQL 的核心就是存储引擎。


**InnoDB** 是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，是默认的 MYSQL 引擎。

**MyISAM** 基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其它应用环境下最常使用的存储引擎之一。具有较高的插入、查询速度，但不支持事务。

**MEMORY** 将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。

如果要提供提交、回滚、崩溃恢复能力的事务安全能力，并要求实现并发控制，InnoDB 是一个好的选择。

如果数据表主要用来插入和查询记录，则 MyISAM引擎 能提供较高的处理效率。

如果只是临时存放数据，数据量不大，且不需要较高的数据安全性，可以选择将数据保存在内存中的 Memory 引擎，MySQL 使用该引擎作为临时表，存放查询的中间结果。

如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archive

参考：[Mysql四种常见数据库引擎](https://www.jianshu.com/p/4bb9f78b4f6d)

>(11) 了解 MVCC 吗？

Multi-Version Concurrency Control，即多版本并发控制，主要是为了提高数据库的并发性能。

MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。通过版本链提高系统的并发性能。


>(12) 悲观锁和乐观锁

悲观锁，即对于数据的处理保持悲观，总认为会发生冲突，获取和修改数据时，别人会修改数据。所以在整个数据处理中，需要将数据锁定。

乐观锁，认为数据一般情况下不会发生冲突。只有提交数据更新时，才会对数据是否冲突进行检测。

>(13) mysql 慢查询

[了解慢查询](https://juejin.cn/post/7155515257350258695)

[美团：基于AI+数据驱动的慢查询索引推荐](https://tech.meituan.com/2023/04/06/slow-query-optimized-driven-by-ai-data.html)

>(14) 解释一下数据库中的幂等

在数据库中，幂等是指对同一操作的多次执行具有相同的结果，不会对数据库的状态产生额外的影响。

幂等性在数据库中非常重要，特别是在处理事务和并发操作时。

它可以确保在并发环境下，多个用户或进程对同一数据进行操作时，不会出现数据的不一致性或冲突。


>(15) 解释一下SQL中二级索引

二级索引是指在关系数据库中，除了主键索引外，还可以创建其他的索引。

主键索引是数据库表中的一列或多列，用于唯一标识每一行数据，而二级索引则是对表中的其他列或多列进行索引，用于提高查询效率。

需要注意的是，虽然二级索引可以提高查询效率，但也会增加数据库的存储空间和写入性能。

因为每次插入、更新或删除数据时，都需要维护二级索引的结构。

因此，在设计数据库时，需要权衡使用二级索引的利弊，根据实际需求来确定是否需要创建二级索引，以及需要创建哪些列的索引。


>(16) 了解分布式死锁吗？

分布式死锁，指多个事务在同时访问共享资源时发生的循环依赖关系，导致死锁。


解决方法1：重新设计数据库事务，确保事务按正确事务执行（比如：行锁方面，进行排序）

解决方法2：调整应用程序的架构，如使用更高级别的分布式系统，如消息队列，分布式锁等




## 4.2 Redis

参考：
- [面试官：你对Redis缓存了解吗？面对这11道面试题你是否有很多问号？](https://zhuanlan.zhihu.com/p/136796077)

>(1) 了解 Redis 吗

Redis 是一个开源的、C实现的、高性能的、基于内存的、单线程的Key_value系统。

适用于高QPS、低延迟、若持久化的场景，用作缓存。

>(2) redis 支持的数据类型？

- String 字符串（做简单的KV操作）
- Hash 散列（类似 map 的一种结构，将一个结构化的数据缓存给 redis）
- List 列表
- Set 集合（自动去重）
- Sorted Set 有序集合

>(3) redis 持久化

持久化，即将数据写入内存的同时，异步地将数据写入磁盘文件里。主要用于灾难恢复、数据恢复。

持久化的两种机制：
- RDB(Redis DataBase)，对 redis 中的数据执行周期性的保存
- AOF(Append Only File)，将每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集

>(4) 常见的缓存问题

缓存用于：加快页面打开速度，减少网络带宽消耗，降低服务器压力

>(5) redis 和 memcached 有什么区别？redis 的线程模型是什么？

redis 支持更加复杂的数据结构，redis 原生支持集群模式。redis只使用单核，而memcached可以使用多核，平均每一个核上redis在存储小数据时比memcached性能更高。而在100k以上数据中，memcached性能要高于redis.

>(6) 为什么 redis 单线程却能支撑高并发？Redis快速原因？

- redis 是基于内存的，内存的读写速度比磁盘快很多
- redis 是单线程的，省去了许多上下文切换的时间
- redis 使用了epoll多路复用技术，可以处理并发的连接


>(7) 了解什么是 redis 的雪崩、穿透和击穿？redis 崩溃之后会 怎么样？系统该如何应对这种情况？如何处理 redis 的穿透？

缓存雪崩和穿透是缓存最大的两个问题，一旦出现就是致命性的问题。

**缓存雪崩**：假设服务器每日高峰期会有5000个请求，缓存能抗住4000个。然后缓存机器宕机了，这时所有请求落在数据库系统上了，他会报一下警，然后挂掉。重启也会被新的流量撑死。

缓存雪崩的事前事中事后的解决方案如下。 
- 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。 
- 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。 
- 事后：redis持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

**缓存穿透**：即服务器收到很多的不在缓存中，也不在数据库中的请求，比如黑客的恶意攻击，这时大量的请求会影响数据库系统的稳定性。

解决方法：将没查到写一个空值到缓存里去，如：set -999 UNKNOWN，然后设置一个过期时间

**缓存击穿**：某个key值的访问非常频繁，在这个key失效时，大量的缓存就击穿了缓存，直接请求数据库。

解决方法：将热点数据设置为永不过期；或基于 redis or zookeeper 实现互斥锁

>(8) 了解 redis 集群吗？

Redis 集群是 Redis 提供的**分布式数据库方案**，集群通过分片来实现数据共享，并提供复制和故障转移。

Redis 支持三种集群方案：
- 主从复制模式
- Sential(哨兵)模式
- Cluster 模式

参考：[一文读懂 Redis 集群](https://cloud.tencent.com/developer/article/1592432)

>(9) 数据不一致问题

一般的业务场景都是读多写少的，当客户端的请求太多，对数据库的压力越来越大，引入缓存来降低数据库的压力是必然选择，目前业内主流的选择基本是使用 Redis 作为数据库的缓存。但是引入缓存之后，可能出现缓存与数据库的数据一致性问题。

根据不同的业务，不同的数据一致性要求，结合系统的性能综合考虑，选择适合自己系统的方案就好。
- 先操作 Redis，再操作数据库
- 先操作数据库，再操作 Redis

总的来说，由于我们的基本原则是以数据库为准，那么我们选择的方案就应该把操作数据库放到前面，也就是说我们应该先操作数据库，再操作 Redis，对于并发很高的场景，我们可以在操作数据库之前通过消息队列来降低客户端对数据库的请求压力。

参考：[Redis 的数据一致性方案分析](https://zhuanlan.zhihu.com/p/141537171)

## 4.3 语句练习




-----------

参考资料：
- 牛客
- chatgpt