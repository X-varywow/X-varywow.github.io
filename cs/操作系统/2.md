考纲内容：
- 进程与线程
  - 进程/线程的基本概念；状态与转换
  - 线程的实现：内核支持的线程，线程库支持的线程
  - 进程与线程的组织与控制
  - 进程间通信：共享内存，消息传递，管道
- CPU 调度与上下文切换
  - 调度的基本概念；调度的目标
  - 调度的实现：调度器/调度程序，调度的时机与调度方式（抢占式、非抢占式），闲逛进程，内核级线程与用户级线程调度
  - 典型调度算法：先来先服务；短作业优先；时间片轮转；优先级调度；高响应比有限；多级队列；多级反馈队列
  - 上下文及其切换机制
- 同步与互斥
  - 同步与互斥的基本概念
  - 基本的实现方法：软件方法；硬件方法
  - 锁；信号量；条件变量
  - 经典同步问题：生产者-消费者问题，读者-写者问题；哲学家就餐
- 死锁
  - 死锁的基本概念；死锁预防
  - 死锁避免；死锁检测和解除

## 2.1 进程

进程实体（进程映像）的**组成**:
- `PCB`
  - 进程描述信息（进程标识符`PID`，用户标识符`UID`）
  - 进程控制和管理信息（进程当前状态，进程优先级）
  - 资源分配清单（程序段指针，数据段指针，键鼠）
  - 处理机相关信息（也称处理机的上下文，包括各种寄存器值）
- 数据段
- 程序段

系统为每个运行的程序配置一个数据结构，称为 **进程控制块**（PCB），用来描述进程的各种信息（如程序代码存放位置）.

一般情况下，把进程实体简称为进程。
所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。

PCB是进程存在的 **唯一标志**

- 进程是程序的`一次执行过程`
- 进程是【进程实体的运行过程，是系统进行资源分配和调度的一个独立单位】（进程是 **动态** 的）

----------------------
进程的**组织方式**：
- 链接方式
  - 按照进程状态将PCB分为多个队列
  - 组成：执行指针、就绪队列指针、阻塞队列指针
- 索引方式
  - 按照进程状态的不同，建立几张索引表
  - 组成：执行指针、就绪表指针、阻塞表指针

------------------------

进程的**特征**：
- `动态`性
  - （进程是动态地产生变化消亡的）
  - 这是进程与程序的根本区别
- 并发性（各进程可并发执行）
- 独立性（进程是资源分配、接受调度的基本单位）
- 异步性（各进程按各自独立的、不可预知的速度向前推进）
- 结构性（每个进程都会配备一个PCB）

----------------------

进程的**状态**：
- 运行态（在CPU上运行）
- 就绪态（具备除处理机外一切所需资源）
- 阻塞态（等待某一事件的发生）
- 创建态（操作系统为其分配资源，初始化PCB）
- 终止态（操作系统回收资源，撤销PCB）

进程状态的切换，就是**进程控制**，用原语实现。

`挂起态`：进程暂时换出外存进行等待。

----------------------

**进程通信**【进程之间的信息交换】：

- 低级通信方式
  - 信号量
- 高级通信方式
  - 共享存储
    - 【要互斥地访问共享空间】
    - 基于数据结构的共享
    - 基于存储区的共享
  - 消息传递
    - 消息缓冲通信
    - 信箱通信
  - 管道通信
    - 【一个管道只能实现半双工通信】

--------------------

## 2.2 线程

`线程` 是一个基本的CPU执行单元，也是程序执行流的最小单元。

线程，可以理解为轻量级进程。

- 引入线程后：
  - 进程只作为除CPU外系统资源的分配单元。
  - 线程是资源调度的基本单位。
  - 进程内的各线程也可以并发，提高了并发度。
  - 进程内线程切换，减小系统开销。
- 线程的实现方式：
  - 用户级线程
  - 内核级线程

---------------------

一些说明：
- `进程` 与 `作业`：一个作业通常包括几个进程，几个进程共同完成一个任务，即作业。
- `进程` 与 `线程`：做个简单的比喻，进程=火车，线程=车厢
  - 线程在进程下行进
  - 同一进程下不同线程间，数据容易共享


进程 ➡ 资源分配的基本单位

线程 ➡ 独立调度的基本单位

------------------

线程的实现方式
- **用户级线程**
  - 【所有工作都有应用程序在用户空间中完成，内核意识不到线程】
  - 优点：线程切换不需要转换到内核空间，节省开销
  - 缺点：
    - 线程执行一个系统调用时，进程内所有线程都会阻塞
    - 内核每次分配给进程的仅有一个CPU，进程中仅    有一个线程能执行
- **内核级线程**
  - 【操作系统只"看得见"内核级线程，因此只有内核级线程才是处理机分配的单位】
- **组合方式**




## 2.3 处理机调度

- 【从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，并实现进程的并发执行】
- 三个层次：
  - 高级调度（作业调度）
    - 对进程状态的影响：无 `->` 创建态 `->` 就绪态
    - 是外存与内存之间的调度
  - 中级调度（内存调度）
    - 对进程状态的影响：挂起态 `->` 就绪态
    - 【决定哪个处于挂起状态的进程重新调入内存】
  - 低级调度（ **进程调度** ）
    - 最基本的一种调度，发生频率最高
    - 对进程状态的影响：就绪态 `->` 运行态
    - `内容`【按照某种算法从就绪队列中选择一个进程为其分配处理机】
    - `方式`
      - 非剥夺调度方式【只允许进程主动放弃处理机】
      - 剥夺调度方式【又称抢占方式，可优先处理紧急进程】

`挂起` 和 `阻塞` 都是暂时不能获得CPU的服务，但 `挂起` 是将进程映像调到外存去了。


--------------------

调度算法的评价指标：
- **CPU利用率** = 忙碌的时间 / 总时间
- **系统吞吐量**：单位时间内完成作业的数量
- **周转时间** = 作业完成时间 - 作业提交时间
- **等待时间**：指进程/作业处于等待处理机状态时间之和
- **响应时间**：从用户提交请求到首次产生响应所用时间


------------------

## 2.4 调度算法⭐

- 先来先服务（FCFS）
  - 不利于短作业
  - **不可抢占**
- 短作业优先（SJF）
  - 平均等待时间最少
  - 长作业会饥饿
- 高响应比优先（HRRN）
  - $响应比 =  等待时间+执行时间/执行时间$
  - 克服了“饥饿”现象
- 时间片轮转调度算法（RR）
- 优先级调度算法
- 多级反馈队列调度算法

-------------------

进程优先级：
- 系统进程 > 应用进程
- 交互型 > 非交互型
- IO型 > 计算型


## 2.5 同步与互斥

`临界资源`：一次仅允许一个进程使用的共享资源。（互斥共享资源）（如：打印机、磁带机、消息队列等）

- **进程同步**
  - 【并发性带来了异步性，有时需要进程同步来解决异步问题】
- **进程互斥**
  - 【对临界资源的访问，需要互斥地进行】
  - 四个部分
    - 进入区【上锁】
    - `临界区`【访问临界资源的代码】
    - 退出区【解锁】
    - 剩余区【其余代码部分】
  - 遵循原则：
    - 【空闲让进】【忙则等待】【有限等待】【让权等待】
  - 软件实现方法：`？？？`
    - 单标志法（违背空闲等待）
    - 双标志先检查（违背忙则等待）
    - 双标志后检查（双方互相谦让，导致饥饿）
    - Peterson算法（无法实现让权等待）
  - 硬件实现方法：`？？？`
    - 中断屏蔽方法
      - 关中断 -> 临界区 -> 开中断
    - TestAndSet（TS指令/TSL指令）
    - Swap指令（XCHG指令）

用户进程可以通过使用操作系统提供的一对原语对`信号量`进行操作，从而方便实现进程互斥、同步。


----------------------

管程，是一种进程同步机制；为了解决信号量机制中容易操作不当的问题。

- 结构
  - 定义共享数据
  - 定义访问数据的入口
- 其互斥特性，由编译器负责实现


## 2.6 PV 操作 ⭐

`信号量` 是种表示系统资源的变量。
- 整型信号量
- 记录型信号量（默认）
  - P操作时，若资源不足，记录到 进程链表L 并 block 该进程
  - V操作时，若 L 不为空，wakeup L中的进程


`wait`、`signal` 原语的操作简称 `PV操作`

```c
// 生产者-消费者问题
semaphore mutex = 1; // 实现互斥，互斥访问临界区
semaphore empty = n; // 实现同步
semaphore full = 0;

producer(){
  while(1){
    生产物品;
    P(empty);
    P(mutex);
    将物品放入缓冲区;
    V(mutex);
    V(full);
  }
}

consumer(){
  while(1){
    P(full);
    P(mutex);
    取走物品;
    V(mutex);
    V(empty);
  }
}

// 实现互斥的 P 操作一定放在，实现同步的 P 操作后面
// V 操作顺序可以互换
```

```c
// 读者-写者问题
int count = 0;       // 记录读者数量
semaphore mutex = 1; // 对 count 变量互斥访问
semaphore rw = 1;    // 实现 读者-写者 间的互斥
semaphore w = 1;     // 实现 写优先

writer(){
  while(1){
    // P(w);
    P(rw);
    writing;
    V(rw);
    // V(w);
  }
}

reader(){
  while(1){
    // P(w);
    P(mutex)
    if(count == 0)
      P(rw);
    count++;
    V(mutex);
    // V(w);

    reading;

    P(mutex);
    count--;
    if(count == 0)
      V(rw);
    V(mutex);
  }
}

// 利用互斥访问的 count 变量，使另一互斥进程得以互斥，而本身不会互斥
```

```c
// 哲学家进餐问题
semaphore chopsticks[5] = {1, 1, 1, 1, 1};
semaphore mutex = 1;
Pi(){
  while(1){
    P(mutex);    // 互斥使用筷子
    P(chopsticks[i]);
    P(chopsticks[(i+1)%5]);
    V(mutex);
    eat;

    V(chopsticks[i]);
    V(chopsticks[(i+1)%5]);
    think;
  }
}

```

```c
// 吸烟者问题
// 三个抽烟者、一个供应者；使轮流抽烟
int i = 0; // 利用随机数代表组合
semaphore offer1 = 0;
semaphore offer2 = 0;
semaphore offer3 = 0;
semaphore finish = 0;

provider(){
  while(1){
    if(i == 0){
      将组合1放桌上；
      V(offer1);
    }else if(i == 1){
      将组合2放桌上;
      V(offer2);
    }else if(i == 2){
      将组合3放桌上;
      V(offer3);
    }
    i = (i+1)%3
    P(finish)
  }
}

smoker1(){
  while(1){
    P(offer1);
    拿走组合1；卷烟；抽掉；
    V(finish);
  }
}

smoker2(){
  while(1){
    P(offer2);
    拿走组合2；卷烟；抽掉；
    V(finish);
  }
}

smoker3(){
  while(1){
    P(offer3);
    拿走组合3；卷烟；抽掉；
    V(finish);
  }
}
```

```c
//理发师问题
//理发店有一位理发师，n把椅子；

int waiting = 0;
semaphore mutex = 1; //互斥地访问 waiting 变量
semaphore customers = 0; //用于实现等待顾客同步关系
semaphore tony = 0; //用于实现顾客等待理发师同步关系

Tony(){
  while(1){
    P(consumers);
    p(mutex);
    waiting--;
    V(mutex);
    V(tony);
    理发；
  }
}

customer(){
  P(mutex);
  if(waiting<n){
    waiting++;
    V(mutex);
    V(customers); //唤醒理发师
    P(tony);
    接受理发;
  }
  else
    V(mutex); //离开
}

```

## 2.7 死锁

死锁：多个进程因竞争资源造成的一种僵局（互相等待）

<img src="https://img-blog.csdnimg.cn/20200131121557463.jpg" style="zoom:30%">

### 2.7.1 死锁产生的必要条件

- 互斥条件（进程对资源的使用是互斥的）
- 不剥夺条件（进程获得的资源只能主动释放）
- 请求并保持条件（进程占有资源的同时，可提出新的请求）
- 循环等待条件

### 2.7.2 死锁的处理策略

- 不允许发生
  - 静态（`预防死锁`）
    - 破坏互斥：基本不行
    - 破坏不剥夺：剥夺资源
    - 破坏请求并保持：一次请求所有资源
    - 破坏循环等待：资源按序分配
  - 动态（`死锁避免`）
    - 在资源动态分配过程中，防止系统进入不安全状态（无法找到安全序列）
    - 银行家算法（参考 2.6）
- 允许发生
  - `死锁的检测和解除`
    - 检测
      - 利用 资源分配图 来描述
      - 死锁定理，当S状态的资源分配图是不可以完全化简的
    - 解除
      - 资源剥夺法
      - 撤销进程法
      - 进程回退法


## 2.8 银行家算法 ⭐

- 数据结构描述：
  - 可利用资源向量 Available
  - 最大需求矩阵 Max
  - 分配矩阵 Allocation
  - 需求矩阵 Need = Max - Allocation
- 银行家算法描述
  - 检查 request 与最大需求
  - 检查可用资源
  - 试着分配，更改数据
  - 检查安全性
- 安全性算法
  - 检查是否存在安全序列


