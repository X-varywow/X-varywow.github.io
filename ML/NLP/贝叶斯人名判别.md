
### é¢˜ç›®è¦æ±‚

ç»™å®šäººåè®­ç»ƒè¯­æ–™ï¼Œé‡‡ç”¨æœ´ç´ è´å¶æ–¯åˆ†ç±»æ¨¡å‹ï¼Œç»™å®šä»»æ„ä¸€ä¸ªå§“åï¼Œåˆ¤æ–­å…¶æ€§åˆ«ã€‚


### åŸºæœ¬åŸç†

?> _æœ´ç´ è´å¶æ–¯_
æœ´ç´ è´å¶æ–¯æ˜¯åŸºäºè´å¶æ–¯å®šç†ä¸ç‰¹å¾æ¡ä»¶ç‹¬ç«‹å‡è®¾çš„åˆ†ç±»æ–¹æ³•ã€‚$$y=\arg \max _{c_{k}} P\left(Y=c_{k}\right) \prod_{j=1}^{n} P\left(X_{j}=x^{(j)} | Y=c_{k}\right)$$

ç‰¹å¾ï¼šè¿™é‡Œåªåšäº†ä¸€ä¸ªç‰¹å¾ï¼Œå°±æ˜¯ äººåï¼ˆå»æ‰å§“æ°ï¼‰ã€‚

æ ‡ç­¾ï¼šç”·æˆ–å¥³ï¼ŒæŠŠæœªçŸ¥å»æ‰ï¼›

### ä»£ç å®ç°

_è¯­æ–™å¤„ç†_

```python
from tqdm import tqdm
from sklearn.model_selection import train_test_split
import numpy as np

X, Y = [], []
cnt = len(open("person.txt",'r',encoding="gbk").readlines())

with open("person.txt","r", encoding="gbk") as f:
    with tqdm(total=cnt) as pbar:
        for line in f.readlines():
            pbar.update(1)
            line = line.strip()
            try:
                name, sex = line.split(",")
                if sex == "æœªçŸ¥":
                    continue
                X.append(name[1:]) #é»˜è®¤é‡‡ç”¨å•å§“
                Y.append(sex) 
            except:
                pass
                
x_train, x_test, y_train, y_test = train_test_split(X, Y, train_size = 0.7)

print(X[:5], Y[:5])
print(x_test[:5], y_test[:5])
```


_è®¡ç®—ç»“æœ_

```python
from collections import Counter

class NaiveBayes:
    def __init__(self):
        self.d0 = Counter()
        self.d1 = Counter()
        self.n0 = 0
        self.n1 = 0
        
    def fit(self, x_train, y_train):
        with tqdm(total=len(x_train)) as pbar:
            for x,y in zip(x_train, y_train):
                pbar.update(1)
                if y == "ç”·":
                    self.d1[x] += 1
                    self.n1 += 1
                else:
                    self.d0[x] += 1
                    self.n0 += 1
        
    def score(self, x_test, y_test):
        cnt, all_cnt = 0, 0
        for x,y in zip(x_test, y_test):
            all_cnt += 1
            if (self.predict(x)=="0") == (y=="å¥³"):
                cnt += 1
        print("å¾—åˆ†ï¼š", cnt/all_cnt)
            
    def predict(self, name):
        name = name[1:]
        p_0 = self.n0/(self.n0 + self.n1)
        p_1 = self.n1/(self.n0 + self.n1)
        p_0 *= (self.d0.get(name, 0)+1)/(self.n0 + 2)  # å¹³æ»‘
        p_1 *= (self.d1.get(name, 0)+1)/(self.n1 + 2)
        
        return 0 if p_0 > p_1 else 1
            
if __name__ == "__main__":
    name = input()
    model = NaiveBayes()
    model.fit(x_train, y_train)
    model.score(x_test, y_test)
    if model.predict(name):
        print("é¢„æµ‹ä¸ºï¼šç”·ç”Ÿ")
    else:
        print("é¢„æµ‹ä¸ºï¼šå¥³ç”Ÿ")
```
>å¾—åˆ†ï¼š 0.6434520794642354

>å´æ©è¾¾ é¢„æµ‹ä¸ºï¼šç”·ç”Ÿ


<img src="https://img-1301102143.cos.ap-beijing.myqcloud.com/202112111502476.jpg">


_ç»“æœéªŒè¯_

!> æ‰“ç®—ç”¨ sklearn çš„è´å¶æ–¯éªŒè¯ï¼›èƒ½åŠ›æœ‰é™ï¼ŒéªŒè¯ä¸äº†ï¼Œéƒ½å¿«å¿˜å…‰äº†ğŸ˜…

```python
from sklearn.naive_bayes import MultinomialNB
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_extraction.text import TfidfTransformer


x_train = np.array(x_train).reshape(-1,1)
y_train = np.array(y_train).reshape(-1,1)
# count_vect = CountVectorizer()
# X_train_counts = count_vect.fit_transform(x_train)
# tfidf_transformer = TfidfTransformer()
# X_train = tfidf_transformer.fit_transform(X_train_counts)
model = MultinomialNB().fit(x_train, y_train)


print("å‡†ç¡®ç‡ä¸º:",model.score(x_test, y_test))
```

æŠ¥é”™1ï¼š`ValueError: Unable to convert array of bytes/strings into decimal numbers with dtype='numeric'`

!> æ˜¯æ”¾åˆ°æ¨¡å‹çš„æ•°æ®è¦ç”¨æ•°å­—è¡¨ç¤ºå—ï¼Ÿä¸­æ–‡ä½¿ç”¨è¯å‘é‡è¿˜æ˜¯æŠ¥é”™...




å‚è€ƒæ–‡ç« ï¼š
- [sklearn.model_selection.train_test_split](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html)
- [1.9. Naive Bayes](https://scikit-learn.org/stable/modules/naive_bayes.html)
