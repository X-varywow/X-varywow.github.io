
### preface

通过**局部最优**得到全局最优解。

## 跳跃游戏


### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

>思路：维护一个变量 k, 为最远可以跳的位置

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        k = 0
        for i,num in enumerate(nums):
            if i>k:
                return False
            k = max(k,i+nums[i])
        return True
```

### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        pos = len(nums)-1
        steps = 0
        while pos>0:
            for i in range(pos):
                if i+nums[i]>=pos:
                    pos = i
                    steps += 1
                    break
        return steps
```


### [1345. 跳跃游戏 IV](https://leetcode-cn.com/problems/jump-game-iv/)

给你一个整数数组 `arr` ，你一开始在数组的第一个元素处（下标为 0）。

每一步，你可以从下标 `i` 跳到下标：
- `i + 1` 满足：`i + 1 < arr.length`
- `i - 1` 满足：`i - 1 >= 0`
- `j` 满足：`arr[i] == arr[j] 且 i != j`

请你返回到达数组最后一个元素的下标处所需的最少操作次数。

注意：任何时候你都不能跳到数组外面。

```python
#BFS 优先队列解决最短路径问题
class Solution:
    def minJumps(self, arr: List[int]) -> int:
        same = defaultdict(list)
        for i,num in enumerate(arr):
            same[num].append(i)

        vis = set([0])
        q = deque([(0,0)])
        while q:
            idx, step = q.popleft()
            if idx == len(arr)-1:
                return step
            v = arr[idx]
            step += 1
            for i in same[v]:
                if i not in vis:
                    vis.add(i)
                    q.append((i, step))
            del same[v] #删除子图
            if idx+1<len(arr) and idx+1 not in vis:
                vis.add(idx+1)
                q.append((idx+1, step))
            if idx-1>=0 and idx-1 not in vis:
                vis.add(idx-1)
                q.append((idx-1, step))
```

## 买卖股票的最佳时机


### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

一股股票，最多交易一次

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        cost = float('inf')
        res = 0
        for p in prices:
            cost = min(p,cost)
            res = max(res, p-cost)
        return res
```

### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

一股股票，可以交易多次

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        pre = prices[0]
        res = 0
        for i in range(1, len(prices)):
            num = prices[i]
            if num > pre:
                res += (num - pre)
            pre = num

        return res
```


```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        res = 0
        for i in range(1, len(prices)):
            res += max(0, prices[i]-prices[i-1])
        return res
```

### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)


一股股票，最多交易两次

>二维动态规划

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        n = len(prices)
        dp = [[0]*n for _ in range(3)]

        for k in range(1,3):
            pre = - prices[0]
            for i in range(1, n):
                pre = max(pre, dp[k-1][i-1] - prices[i])   # 为持股的，最小的支出
                dp[k][i] = max(dp[k][i-1], pre + prices[i])

        return dp[-1][-1]
```


### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)


一股股票，最多交易 k 次

```python
# 同 III，多维动态规划
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0
        n = len(prices)
        dp = [[0]*n for _ in range(k+1)]

        for kk in range(1,k+1):
            pre = - prices[0]
            for i in range(1, n):
                pre = max(pre, dp[kk-1][i-1] - prices[i])   # 为持股的，最小的支出
                dp[kk][i] = max(dp[kk][i-1], pre + prices[i])

        return dp[-1][-1]
```


## [517. 超级洗衣机](https://leetcode-cn.com/problems/super-washing-machines/)

```python
class Solution:
    def findMinMoves(self, machines: List[int]) -> int:
        n = len(machines)
        if sum(machines)%n:
            return -1

        avg = sum(machines)//n
        ans, cur = 0, 0

        # 每台洗衣机足够聪明，移到左边的不会右移，同理
        # 移出与移入不同，移入可以从两边移入，操作数可以小于差值
        for num in machines:
            num -= avg
            cur += num
            ans = max(ans, num, abs(cur))
        
        return ans
```



## [1326. 灌溉花园的最少水龙头数目](https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/)


方法一：dp

```python
class Solution:
    def minTaps(self, n: int, ranges: List[int]) -> int:
        intervals = []
        for i,r in enumerate(ranges):
            start = max(0, i-r)
            end = min(n, i+r)
            intervals.append([start,end])
        intervals.sort()
        
        dp = [inf] * (n+1)
        dp[0] = 0

        for start,end in intervals:
            if dp[start] == inf:
                return -1
            for j in range(start, end+1):
                dp[j] = min(dp[j], dp[start] + 1)
            
        return dp[n]
```
时间复杂度：O(n×(log⁡n+max⁡(ranges)))



方法二：贪心
```python
class Solution:
    def minTaps(self, n: int, ranges: List[int]) -> int:
        intervals = []
        for i,r in enumerate(ranges):
            start = max(0, i-r)
            end = min(n, i+r)
            intervals.append([start,end])
        intervals.sort()
        
        dp = [inf] * (n+1)
        dp[0] = 0

        for start,end in intervals:
            if dp[start] == inf:
                return -1
            for j in range(start, end+1):
                dp[j] = min(dp[j], dp[start] + 1)
            
        return dp[n]
```
时间复杂度：O(n)